---
layout: post
title:  "What is a Monad in Haskell?"
date:   2019-09-06 09:30:44 -0400
categories: haskell basic 
mathjax: true
---
- [Introduction](#introduction)
- [Application - Filtering a List](#application---filtering-a-list)
- [Questions](#questions)

# Introduction
<div style="text-align:center; margin-bottom:13px;">
    <img style="border:solid thin black" src="lamb-the-lambda/img/bindType.png" width="500" height="56" />
</div>

This is the main thing you need to know. A [Monad](https://wiki.haskell.org/Monad) is a type which has this operation called *bind* ( among others, but we'll keep it simple) defined. Here are the three parts:

1. `m a` - we have a container that contains a value of type `a`.
2. `( a -> m b)` - we have a function that takes an `a` and puts it in the container and potentially converts the type inside to a new type, although `a` can equal `b`, so the *bind* doesn't have to convert the type inside the monad to another type.
3. `m b` - we have our new container updated with the value produced by applying *(2)* to *(1)*.
Let's see this in action by using the List monad to create a list filter.

# Application - Filtering a List

```haskell
[34,2,3,14] >>= \x -> if x > 10 then [x] else []
```

When we execute this code, we get: `[34,14]`. Let's look at the terms in this expression.

1. `[34,2,3,14]` - we have an object of type `[Int]`. Lists are monads, i.e. they provide an definition for bind and the other monad operators, and we can rewrite the type of this object as `[] Int`. So we see that `[]` lines up with `m` and `Int` lines up with `a` in the first argument of the *bind* operator.
2. `>>=` - we have our *bind* operator. We know that the left hand side of this operator has the proper type, so things are looking good so far, but what about the right hand side *(3)*?
3. `\x -> if x > 10 then [x] else []` - here we have a function which takes an x and puts it in the same box as the elements of *(1)* are in -- namely a list. So we know this has the type of `(a -> m b)`, which when we fill these values in becomes: `Int -> [] Int`. So we have a valid use of the *bind* which, when we substitute the type variables for the particular example we have, has the type: `[] Int -> ( Int -> [] Int ) -> [] Int`. Let's now review the internals of this lambda function and how it is used to filter items.
    1. `x > 10` - here's our filter predicate. If it is true we return *(3.2)*, otherwise we return *(3.3)*.
    2. `[x]` - we put our value into the list box when it satisfies our filter predicate *(3.1)*.
    3. `[]` - if our value does not satisfy our filter predicate *(3.1)*, then we return an empty box.


# Questions
1. How would you use this to create your own `filter :: (a -> Bool) -> [a] -> [a]` function?
2. Can `concat :: Foldable t => t [a] -> [a]` and `map :: (a -> b) -> [a] -> [b]` be used to create a filter function?
3. Instances of monads also define `return :: Monad m => a -> m a`. How would we use this in place of `[x]` in *(3.2)*?